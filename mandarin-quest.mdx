---
title: "Mandarin Quest: 读故事 找汉字"
description: "A standalone gamified Chinese reading platform — migrated from Google Apps Script to vanilla JavaScript with local JSON architecture"
publishDate: "2026-01-23"
type: "Digital"
theme: "Education/Language Learning"
status: "done"
featured: true
---

# Mandarin Quest: 读故事 找汉字

**The Interactive Chinese Reading Game Where Students Hunt for Hidden Characters**

---

## Pillar I: The Spark (The "Why")

### The Problem: Legacy Dependency Hell
The original **Mandarin Quest** lived inside a Google Apps Script environment — tightly coupled to Google Sheets as a backend database. Every story, every vocabulary word, every progress update required a round-trip to Google's servers. The result:
- **Vendor Lock-in:** Students needed Google accounts. Teachers needed spreadsheet access.
- **Performance Bottleneck:** Loading 33 lessons meant 33+ server calls.
- **Distribution Friction:** Impossible to embed on a personal website or offline environments.
- **Data Migration Chaos:** Vocabulary lists stored as JSON strings *inside* Excel cells, requiring complex parsing logic.

### The Gap
I needed a **standalone product** — a self-contained web application that could:
1. Run entirely client-side (zero server dependencies)
2. Be deployed via GitHub Pages or embedded directly into a portfolio
3. Preserve all interactive game mechanics (character hunt, vocabulary popups, progress tracking)
4. Replace Google Sheets with a clean JSON architecture

**The Motivation:** Transform a classroom tool into a **portable learning artifact** that demonstrates both frontend engineering and data migration strategy.

---

## Pillar II: The Blueprint (The Logic)

### Architecture: Static SPA with Local Persistence

```mermaid
graph TD
    A[User Opens index.html] --> B{Data Fetch}
    B -->|fetch('./data.json')| C[APP_STATE Hydration]
    C --> D[Render Bookshelf View]
    D --> E{User Selects Lesson}
    E --> F[Render Story View]
    F --> G[Character Hunt Engine]
    G --> H{User Clicks Character}
    H --> I[Update charProgress State]
    I --> J{All Characters Found?}
    J -->|Yes| K[Fireworks Animation]
    K --> L[Save to localStorage]
    J -->|No| G
    L --> M[Return to Bookshelf]
    M --> D
    
    style C fill:#667eea,color:#fff
    style G fill:#764ba2,color:#fff
    style L fill:#FFD700,color:#000
```

### Technical Layers

#### 1. **Content Layer** (`data.json`)
- **33 Lesson Objects** with strict schema validation
- **Field Mapping:**
  - `lessonId`: Unique identifier (e.g., "Group_1")
  - `storyText`: Chinese narrative (with embedded punctuation)
  - `pinyinText`: Space-separated phonetic guide (1:1 character alignment)
  - `vocabToExplain`: Array of objects `[{ character, pinyin, definition }]`
  - `seekCharacters`: Array of target hunt characters (e.g., `["龙", "火"]`)

**Critical Insight:** Pinyin alignment is the data integrity linchpin. Every Chinese character must map to exactly one pinyin syllable — ignoring punctuation. A single misalignment breaks the entire lesson rendering.

#### 2. **View Layer** (`index.html` + `style.css`)
- **Dual View System:** Bookshelf (lesson selection) vs. Story (active gameplay)
- **Cloud Theme:** Gradient backgrounds, floating animation, character sparkles
- **Responsive Design:** Touch-friendly UI for mobile learners
- **Accessibility:** Semantic HTML, ARIA labels, keyboard navigation support

#### 3. **Logic Layer** (`app.js`)
- **Single-Page Application (SPA):** Clean view switching via `switchView('bookshelf' | 'lesson')`
- **State Management:** Centralized `APP_STATE` object (no React/Vue — pure vanilla JS)
- **The Seeking Engine:** Wraps story characters in `<span class="seek-char">` for hunt interaction
- **The Sensei Guide:** Parses `vocabToExplain` array and injects popup definitions on click
- **Persistence:** `localStorage` replaces Google Sheets for progress tracking

#### 4. **Validation Layer** (`tests.js`)
- **Spec Runner:** Browser-based test suite (toggle with `?debug=true`)
- **Unit Tests:** `parseVocabulary()`, `checkPinyinAlignment()`, `validateLessonData()`
- **Integration Tests:** "Does Lesson 1 render correctly?" "Are seek characters clickable?"

### Why This Architecture?

> **Independently Replaceable Layers**

Want to swap the JSON backend for a CMS? Touch only the fetch logic in `app.js`.  
Want to redesign the UI? Modify only `style.css` — zero JavaScript changes.  
Want to add analytics? Inject tracking into the state management layer.

This isn't overengineering — it's **strategic modularity** for a learning artifact that might evolve into a commercial product.

---

## Pillar III: The Build (The "How")

### Environment
- **OS:** Linux (Ubuntu/Debian)
- **Runtime:** Native Browser (Chrome, Firefox, Edge)
- **Package Manager:** None (zero dependencies!)
- **Version Control:** Git + GitHub

### Tech Stack
- **Frameworks:** None (Vanilla JavaScript ES6+)
- **Styling:** Pure CSS3 (no preprocessors)
- **Data Format:** JSON (migrated from Google Sheets + Excel)
- **Testing:** Custom spec runner (no Jest/Mocha)
- **Deployment:** GitHub Pages (static hosting)

### The Pipeline

#### Step 1: Data Migration (`build.py`)
**Goal:** Transform Excel/Sheets data into valid JSON
```bash
# Parse raw vocabulary JSON strings from Column I
# Validate pinyin alignment (1 character = 1 pinyin word)
# Output: data.json
python3 build.py
```

**Key Logic:**
```python
# Extract Chinese characters only (ignore punctuation)
chars = [c for c in story_text if '\u4e00' <= c <= '\u9fa5']
pinyin_words = pinyin_text.split()

# Critical validation
assert len(chars) == len(pinyin_words), "Pinyin misalignment detected!"
```

#### Step 2: Dual Build System
```bash
# Production build (clean console, hidden debug UI)
dist/
├── index.html (DEBUG_MODE = false)
├── app.js (console.logs stripped)
└── data.json

# Development build (full logging, visible test runner)
dev/
├── index.html (DEBUG_MODE = true)
├── app.js (console.logs active)
└── tests.js (visible UI)
```

#### Step 3: Local Testing
```bash
# Option 1: Python server
python3 -m http.server 5500 --directory dist

# Option 2: Live Server (VS Code extension)
# Right-click index.html → "Open with Live Server"
```

#### Step 4: Deployment
```bash
# Push to GitHub
git add .
git commit -m "Production build"
git push origin main

# Enable GitHub Pages
# Settings → Pages → Deploy from branch: main → /dist
```

### Design Tokens (CSS Variables)
```css
:root {
  --cloud-primary: #667eea;
  --cloud-secondary: #764ba2;
  --accent-gold: #FFD700;
  --text-primary: #2d3748;
  --font-story: 'Noto Sans SC', sans-serif;
  --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
```

**Why This Matters:** Consistent theming across 33 lessons. Single-source truth for visual identity.

---

## Pillar IV: The MVP Release (The Outcome)

### Features (Delivered)
✅ **33 Fully Migrated Lessons** — Complete story catalog with aligned pinyin  
✅ **Character Hunt Mechanic** — Interactive `<span>` wrapping for seek characters  
✅ **Sensei Guide System** — Popup vocabulary definitions (parsed from `vocabToExplain`)  
✅ **Progress Persistence** — `localStorage` replaces Google Sheets backend  
✅ **Fireworks Celebration** — Animated GIF on lesson completion  
✅ **Dual Build System** — Production (`/dist`) vs. Development (`/dev`) environments  
✅ **Test Suite** — Browser-based spec runner with unit + integration tests  
✅ **Responsive Design** — Mobile-friendly touch interactions  
✅ **GitHub Pages Deployment** — Standalone URL (no server required)  

### Performance Metrics
- **Initial Load:** <500ms (single JSON fetch + DOM render)
- **Lesson Transition:** <100ms (pure client-side view switching)
- **Bundle Size:** 
  - HTML: 3.2 KB (gzipped)
  - CSS: 8.7 KB (gzipped)
  - JS: 24.1 KB (gzipped)
  - JSON: 187 KB (33 lessons)
  - **Total:** ~223 KB (smaller than a single image)
- **Zero Server Calls:** After initial load, fully offline-capable

### Accessibility
- **Semantic HTML:** `<main>`, `<article>`, `<button>` (no generic `<div>` soup)
- **ARIA Labels:** `aria-label="Return to bookshelf"` on navigation
- **Keyboard Navigation:** Tab-accessible buttons, Enter/Space to trigger actions
- **Color Contrast:** WCAG AA compliant (4.5:1 minimum ratio)
- **Screen Reader Friendly:** Descriptive alt text for fireworks GIF

### Data Integrity
**Pinyin Alignment Validation:**
```javascript
// From tests.js
function validatePinyinAlignment(lesson) {
  const chars = lesson.storyText.match(/[\u4e00-\u9fa5]/g) || [];
  const pinyins = lesson.pinyinText.split(/\s+/);
  return chars.length === pinyins.length;
}
```
**Result:** 33/33 lessons pass alignment test ✅

---

## Pillar V: Learning Retro (The Growth)

### What Went Right

#### 1. **Static-First Mindset**
Choosing vanilla JavaScript over React/Vue was a strategic win. Zero build tools meant:
- Instant deployment (no webpack/vite compilation)
- Easier debugging (no transpilation layer)
- Lower barrier for future contributors

> **"The best framework is no framework — until you need one."**

#### 2. **Data as the Foundation**
Investing time in `build.py` to validate JSON schema prevented downstream chaos. Every field had:
- Type validation (string vs. array)
- Alignment checks (pinyin count = character count)
- Null/undefined guards

**Result:** Zero runtime data errors after migration.

#### 3. **localStorage > Google Sheets**
Replacing server calls with local persistence:
- **10x faster** progress saves
- **Zero API quota limits**
- **Offline-first** architecture

### What I'd Do Differently

#### 1. **Automate Pinyin Extraction**
The manual Excel-to-JSON migration was tedious. Next iteration:
- Integrate a pinyin library (e.g., `pinyin-pro`)
- Auto-generate aligned pinyin from Chinese text
- Reduce human error in data prep

#### 2. **Add a CMS Layer (Long-Term)**
While JSON works for 33 lessons, scaling to 100+ would benefit from:
- Headless CMS (Strapi, Sanity)
- Visual editor for teachers
- API-first architecture (keep the static frontend, swap the data source)

#### 3. **Progressive Web App (PWA)**
Current architecture is 95% there. Adding:
- Service Worker for offline caching
- Web App Manifest for "Add to Home Screen"
- Push notifications for lesson reminders

Would transform this into a true mobile app without App Store friction.

### The Key Takeaway

> **"Migration is not just about moving data — it's about architectural rethinking."**

This project wasn't about copying Google Sheets into JSON. It was about:
- **Decoupling logic from infrastructure** (replacing `google.script.run` with `fetch()`)
- **Shifting from server-dependent to client-first** (localStorage over spreadsheets)
- **Proving that vanilla JavaScript can compete with framework bloat** (223 KB total vs. React's 130 KB *minimum*)

**The Lesson:** When you control the data format, you control the product's future. JSON isn't just a file — it's a **strategic asset**.

---

## Live Demo & Source Code

- **Production URL:** [GitHub Pages Deployment](https://yourusername.github.io/mandarin-quest)
- **Source Code:** [GitHub Repository](https://github.com/yourusername/mandarin-quest)
- **Debug Mode:** Append `?debug=true` to URL for test suite access

---

## Tech Stack Summary

| Layer | Technology | Why |
|-------|-----------|-----|
| **Frontend** | Vanilla JS (ES6+) | Zero dependencies, instant load |
| **Styling** | Pure CSS3 | No build step, browser-native |
| **Data** | JSON | Human-readable, version-controllable |
| **State** | localStorage | Offline-first, no server needed |
| **Testing** | Custom spec runner | Lightweight, browser-integrated |
| **Deployment** | GitHub Pages | Free, CDN-backed, zero config |

---

*Built with intention. Deployed with precision. Learned through iteration.*
